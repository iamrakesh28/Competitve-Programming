I want to reach my home

This question exclusively belongs to the contest Codekarona on the occasion of Tech-Day at IIT Palakkad.

It's the year 3020, another virus outbreak year. This time its a Zombie Virus.

There is a rectangular grid with n rows and m columns. The grid represents a country and each cell (i, j) represents a city. 
x cities have been affected by COVID-19. Cities having a non-zero number of positive cases are affected cities. It takes one day for the virus to spread from the affected city to the adjacent cities (cities sharing common sides are adjacent to each other). You are stuck in the college and wants to go… You don’t want to travel through affected cities.
You are only allowed to move in the four directions (up, down, left, right). It takes one day for you to travel from the current city to another adjacent city. Let S(x1, y1) and T(x2, y2) represent your source and destination city respectively. If there exists a safe path from the source to the destination, print the path otherwise print “-1”. There could be multiple possible paths, you can print anyone.

First line contains two space separated integers n, m.
Second line contains four space separated integers x1, y1, x2, y2. (x1, y1), (x2, y2) represent S and T respectively.
Next line contains an integer x.
Next x lines contain two space separated integers representing the cell of the affected cities.


**1 <= N * M <= 1000000 

**(x1, y1) != (x2, y2) i.e., Source and Destination are not same

**S and T are not under lockdown and also not affected

3 3
S#.
.T.
.*#


3 3
*.#
.S.
..T


#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>

using namespace std;

const int N = 1e3 + 5;

int dr[] = {-1, 1, 0, 0}, dc[] = {0, 0, -1, 1};
int dist1[N][N], dist2[N][N];
bool visit[N][N];
pair <int, int> par[N][N];
char mat[N][N];

bool valid(int i, int j, int n, int m) {
  if (i >= 0 && i < n && j >= 0 && j < m)
    return true;
  return false;
}

void bfs1(int n, int m) {

  queue <pair <int, int>> q;
  for (int i = 0; i < n; ++i)
    for (int j = 0; j < m; ++j)
      if (mat[i][j] == '*') {
	q.push({i, j});
	dist1[i][j] = 0;
	visit[i][j] = true;
      }
      else if (mat[i][j] == '#')
	visit[i][j] = true;
      else
	visit[i][j] = false;
  
  while (q.size()) {
    auto u = q.front();
    q.pop();
    for (int d = 0; d < 4; ++d) {
      int r, c;
      r = dr[d] + u.first, c = dc[d] + u.second;
      if (valid(r, c, n, m) && visit[r][c] == false) {
	visit[r][c] = true;
	dist1[r][c] = dist1[u.first][u.second] + 1;
	q.push({r, c});
      }
    }
  }
  return;
}

void bfs2(pair <int, int> S, int n, int m) {

  queue <pair <int, int>> q;
  for (int i = 0; i < n; ++i)
    for (int j = 0; j < m; ++j)
      if (mat[i][j] == '#')
	visit[i][j] = true;
      else
	visit[i][j] = false;

  visit[S.first][S.second] = true;
  q.push(S);
  dist2[S.first][S.second] = 0;
  
  while (q.size()) {
    auto u = q.front();
    q.pop();
    for (int d = 0; d < 4; ++d) {
      int r, c, t;
      r = dr[d] + u.first, c = dc[d] + u.second;
      t = dist2[u.first][u.second] + 1;
      if (valid(r, c, n, m) && visit[r][c] == false && t < dist1[r][c]) {
	visit[r][c] = true;
	dist2[r][c] = t;
	par[r][c] = {u.first, u.second};
	q.push({r, c});
      }
    }
  }
  return;
}

int main() {
  int n, m;
  scanf("%d%d", &n, &m);
  queue <pair <int, int>> q;
  pair <int, int> S, T;
  for (int i = 0; i < n; ++i)
    for (int j = 0; j < m; ++j) {
      char ch;
      scanf(" %c", &ch);
      if (ch == 'S')
	S = {i, j};
      else if(ch == 'T')
	T = {i, j};
      mat[i][j] = ch;
    }
  bfs1(n, m);
  //cout<<dist1[T.first][T.second]<<endl;
  bfs2(S, n, m);

  //path find

  if (visit[T.first][T.second] == false) {
    puts("-1");
    return 0;
  }
  vector <pair <int, int>> ans;
  pair <int, int> city = T;
  ans.push_back(city);
  while (city != S) {
    city = par[city.first][city.second];
    ans.push_back(city);
  }
  printf("%d\n", ans.size());
  reverse(ans.begin(), ans.end());
  for (auto it : ans)
    printf("%d %d\n", it.first + 1, it.second + 1);
  return 0;
}





// Start of BODY
/**
 * TestStruct members::
 *  testcase_id                   [size_t] ID of the test-case
 *  testcase_input_path           [string] File path to test-case input
 *  testcase_output_path          [string] File path to test-case output generated by the problem solver
 *  testcase_expected_output_path [string] File path to test-case expected output to be matched with
 *  testcase_error_path           [string] File path to test-case STDERR
 *  metadata_file_paths           [vector<string>] File paths to Question metadata (Extra files usually used for defining traning sets)
 *  submission_code_path          [string] File path to submission source code
 *  submission_language           [string] Language token of submission
 *  testcase_result               [bool] Set to true if test-case output matches test-case expected output. Matching is done line by line
 *  testcase_signal               [size_t] Exit code of the test-case process
 *  testcase_time                 [float] Time taken by the test-case process in seconds
 *  testcase_memory               [size_t] Peak memory of the test-case process determined in bytes
 *  data                          [string] <Future use>
 *
 *
 *  ResultStruct::
 *    result      [bool]  Assign test-case result. true determines success. false determines failure
 *    score       [float] Assign test-case score. Normalized between 0 to 1
 *    message     [string] Assign test-case message. This message is visible to the problem solver
**/
#include <queue>

void update(ifstream &fp, string msg, ResultStruct &r_obj, bool correct) {
    if (correct) {
        r_obj.result = true;
        r_obj.score = 1.0f;
        r_obj.message = msg;
    }
    else {
        r_obj.result = false;
        r_obj.score = 0;
        r_obj.message = msg;
    }
    fp.close();
}

bool valid(int i, int j, int n, int m) {
  if (i >= 0 && i < n && j >= 0 && j < m)
    return true;
  return false;
}

void path_checker(vector <pair <int, int>> &path, ifstream &inp, ResultStruct &r_obj) {
    int n, m;
    inp >> n >> m;
    vector <string> mat(n);
    vector <vector <bool>> visit(n, vector <bool> (m, false));
    vector <vector <int>> dist(n, vector <int> (m, 0));
    int dr[] = {-1, 1, 0, 0}, dc[] = {0, 0, -1, 1};
    for (int i = 0; i < n; ++i)
        inp >> mat[i];
    queue <pair <int, int>> q;
    pair <int, int> S, T;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            if (mat[i][j] == '#')
                visit[i][j] = true;
            else if (mat[i][j] == '*') {
                visit[i][j] = true;
                q.push({i, j});
            }
            else if (mat[i][j] == 'S')
                S = {i, j};
            else if (mat[i][j] == 'T')
                T = {i, j};
    if (path[0] != S || path[path.size() - 1] != T)
        return update(inp, "Source/Destination not same as in the input", r_obj, false);
    
    // computes virus reaching time
    while (q.size()) {
        auto u = q.front();
        q.pop();
        for (int d = 0; d < 4; ++d) {
            int r, c;
            r = dr[d] + u.first, c = dc[d] + u.second;
            if (valid(r, c, n, m) && visit[r][c] == false) {
                visit[r][c] = true;
                dist[r][c] = dist[u.first][u.second] + 1;
                q.push({r, c});
            }
        }
    }
    
    // checks the path
    int time_ = 0;
    for (int i = 0; i < path.size() - 1; ++i) {
        auto cur = path[i];
        auto nxt = path[i + 1];
        if (dist[cur.first][cur.second] <= time_)
            return update(inp, "Landed in a infected city", r_obj, false);
        bool val = false;
        for (int d = 0; d < 4; ++d) {
            int r, c;
            r = dr[d] + cur.first, c = dc[d] + cur.second;
            if (valid(r, c, n, m) && make_pair(r, c) == nxt) {
                val = true;
                break;
            }
        }
        if (val == false)
            return update(inp, "Invalid move", r_obj, false);
        time_++;
    }
    auto cur = path[path.size() - 1];
    if (dist[cur.first][cur.second] <= time_)
        return update(inp, "Landed in a infected city", r_obj, false);
    return update(inp, "Correct Answer", r_obj, true);
}

void run_custom_checker(const TestStruct t_obj,
                        ResultStruct &r_obj) {
    //Don't print anything to STDOUT in this function
    //Enter your custom checker scoring logic here
    r_obj.result = true;
    r_obj.score = 1.0f;
    r_obj.message = "Success";
    /*
    ifstream fp(t_obj.testcase_output_path, ios :: in);
    if (fp.is_open() == false)
        return update(fp, "Error in reading output file", r_obj, false);
    int size;
    fp >> size;
    if (size == -1) {
        ifstream exp(t_obj.testcase_expected_output_path, ios :: in);
        if (exp.is_open() == false)
            return update(fp, "Error in reading expected output file", r_obj, false);
        int ans;
        exp >> ans;
        exp.close();
        if (ans == -1)
            return update(fp, "Correct Answer", r_obj, true);
        return update(fp, "Wrong answer, there exists a path", r_obj, false);
    }
    else if (size <= 0)
        return update(fp, "Path length is invalid", r_obj, false);
    vector <pair <int, int>> ans;
    int x, y;
    while (fp >> x >> y)
        ans.push_back({x - 1, y - 1});
    if (ans.size() != size)
       return update(fp, "Total number of cities is inconsistent", r_obj, false);
    ifstream inp(t_obj.testcase_input_path, ios :: in);
    if (inp.is_open() == false)
        return update(fp, "Error in reading input file", r_obj, false);
    fp.close();
    return path_checker(ans, inp, r_obj);
    */
}
// End of BODY
        
